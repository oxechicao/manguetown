<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Criando um comando para ler o nome da branch | Manguetown</title>
    <link rel="stylesheet" href="https://oxechicao.github.io/manguetown/style.css" />
    <link rel="icon" type="image/svg+xml" href="https://oxechicao.github.io/manguetown/fav.png" />
  </head>
  <body>
    <div class="container">
      <header>
        <div class="header-title">
          <h1>
            <a href="https://oxechicao.github.io/manguetown">Manguetown</a>
          </h1>
        </div>
        <nav>
          <ul>
            <li><a href="https://oxechicao.github.io/manguetown">Home</a></li>
            <li><a href="https://oxechicao.github.io/manguetown/posts">Posts</a></li>
            <li><a href="https://oxechicao.github.io/manguetown/projects">Projects</a></li>
            <li>
              <a href="https://github.com/oxechicao/manguetown" target="_blank"
                >Github</a
              >
            </li>
          </ul>
        </nav>
      </header>

      <main>
<div class="blog-layout">
  <article>
    <header class="article-header">
      <h2>Criando um comando para ler o nome da branch</h2>
      
      <small style="color: var(--color-rp-subtle)"
        >07&#x2F;12&#x2F;2025</small
      >
      
    </header>

    <div class="article-content"><h2 id="contexto">Contexto<a class="zola-anchor" href="#contexto" aria-label="Anchor link for: contexto">üîó</a></h2>
<p>COMO uma pessoa desenvolvedora<br />
EU QUERO executar comandos git<br />
PARA que eu possa consultar o nome da branch atual</p>
<p>O comando git para isso √©: <code>git rev-parse --abbrev-ref HEAD</code></p>
<p>Tendo em vista o que queremos fazer e o comando que precisaremos executar, vamos pensar nos crit√©rios.</p>
<ol>
<li>A fun√ß√£o deve ser executar o comando git.</li>
<li>A fun√ß√£o deve receber v√°rios argumentos que juntos ir√£o compor o comando do git</li>
<li>Se ocorrer bem, quero ser capaz de ver o resultado.</li>
<li>Se algo falha ocorrer, quero ser capaz de ler uma mensagem de erro que me ajude a executar corretamente.</li>
</ol>
<p>Pronto, agora temos uma ideia b√°sica de como isso tudo funcionar√°.</p>
<h2 id="sobre-a-implementacao">Sobre a implementa√ß√£o<a class="zola-anchor" href="#sobre-a-implementacao" aria-label="Anchor link for: sobre-a-implementacao">üîó</a></h2>
<p>Iremos implementar o nosso projeto buscando seguir o TDD.
Assim, vamos pensar em pequenos passos, que ser√£o as itera√ß√µes, e dividiremos as etapas desta forma.</p>
<p>Cada etapa ir√° implementar uma por√ß√£o do c√≥digo, executar teste para validar que nada est√° quebrado,
faremos um commit para fecharmos essa etapa, e assim temos um ponto de retorno em caso de algum problema.</p>
<p>Nos testes unit√°rios n√£o devemos depender do ambiente externo a aplica√ß√£o para validarmos o c√≥digo.
Quando quiser validar a funcionalidade desta forma, faremos um teste de integra√ß√£o :)</p>
<p>Assim, para n√£o dependermos do ambiente externo utilizaremos um conceito que abstrai estas depend√™ncias,
os mocks.
Mocks s√£o simula√ß√µes de integra√ß√£o real, utilizados principalmente para em testes unit√°rios
de softwares onde eles substituem alguma depend√™ncia real.
Podendo assim, simular os resultados das suas execu√ß√µes para um comportamento conhecido e desejado.</p>
<h2 id="tdd-primeira-iteracao-iniciando-nossa-funcao-de-teste">TDD: Primeira itera√ß√£o - Iniciando nossa fun√ß√£o de teste<a class="zola-anchor" href="#tdd-primeira-iteracao-iniciando-nossa-funcao-de-teste" aria-label="Anchor link for: tdd-primeira-iteracao-iniciando-nossa-funcao-de-teste">üîó</a></h2>
<p>Na nossa primeira itera√ß√£o iremos inciar a implementa√ß√£o da nossa fun√ß√£o de teste.</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_branch_name_on_success() {
    }
}
</code></pre>
<p>Vamos agora entender o que significa esse pedacinho de c√≥digo. Primeiro, vamos entender como fazemos
a assinatura dos testes.</p>
<h3 id="cfg-test-e-mod-tests"><code>#[cfg(test)]</code> e <code>mod tests</code><a class="zola-anchor" href="#cfg-test-e-mod-tests" aria-label="Anchor link for: cfg-test-e-mod-tests">üîó</a></h3>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    // c√≥digo
}
</code></pre>
<p>A defini√ß√£o do teste se da atrav√©s do atributo de configura√ß√£o <code>cfg()</code>.<br />
Essa defini√ß√£o de atributo de configura√ß√£o (<code>cfg</code>) indicar√° ao compilador que
<strong>mod tests</strong> na linha seguinte √© relacionada aos testes e precisa ser compilado somente quando
executamos os testes atrav√©s de <code>cargo test</code> executado no terminal.</p>
<p>O termo <code>mod</code> indica um que estamos definindo um novo m√≥dulo.
Se compararmos com HTML, seria como abrir uma nova tag dentro de outra:</p>
<pre><code data-lang="html">&lt;arquivo&gt;
  &lt;mod name=&quot;tests&quot;&gt;&lt;/mod&gt;
&lt;/arquivo&gt;
</code></pre>
<p>Sendo o arquivo tamb√©m considerado um m√≥dulo, o <code>mod tests</code> indica que estamos definindo um subm√≥dulo, um m√≥dulo dentro de outro.<br />
A ideia do HTML √© interessante de se trazer porque temos tamb√© um conceito similar: <code>parent</code>.</p>
<p>O que nos leva ao seguinte c√≥digo abaixo</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;
    // c√≥digo
}
</code></pre>
<p>A palavra chave <code>use</code> significa que estamos importando (usando) algo de outro m√≥dulo.<br />
Em outras linguages de programa√ß√£o temos a palavra <code>import</code>, por exemplo.</p>
<p>A palavra chave <code>super</code> acessa o m√≥dulo parente, acima, mais pr√≥ximo, mais externo.<br />
A analogia com html faz um sentido melhor aqui. Quando executa <code>use super::*</code> estamos importando
tudo do nosso <code>parent</code>.<br />
Que no nosso exemplo, seria o arquivo onde implementaremos nosso c√≥digo.<br />
Em vis√£o orientada a objetos, seria como usar extender de outra classe.
Veja os exemplo abaixo.</p>
<hr />
<details>
<summary>Exemplos de c√≥digos em outras linguagens</summary>
<pre><code data-lang="java">// JAVA
class ParentClass {
  public ParentClass() {}
  public void sum() {}
  public void minus() {}
}

class ChildClass extends ParentClass {}

public static void main(String[] args) {
  ChildClass obj = new ChildClass();
  obj.sum();
}
</code></pre>
<pre><code data-lang="python">class ParentClass:
    def __init__(self):
        pass

    def sum(self):
        pass

    def minus(self):
        pass

class ChildClass(ParentClass):
    pass

def main():
    obj = ChildClass()
    obj.sum()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</details>
<hr />
<p>Se n√£o desejar manter o teste dentro do mesmo arquivo, √© poss√≠vel separar o teste usando a seguinte estrutura.</p>
<p>Sendo o arquivo a ser testado nomeado como <code>git.rs</code>:</p>
<ol>
<li>Cria uma pasta com o mesmo nome, no mesmo n√≠vel do arquivo. Exemplo: se <code>src/git.rs</code>, ent√£o temos <code>src/git/</code>.</li>
<li>Cria um arquivo tests.rs dentro da pasta criada. Exemplo: `src/git/tests.rs</li>
<li>Ao fim do arquivo <code>git.rs</code> adicione a linhas abaixo, identificand que o submodulo chamado tests existe e est√° configurado para testes.</li>
</ol>
<pre><code data-lang="rs">#[cfg(test)]
mod tests;
</code></pre>
<p>Assim em <code>src/git/tests.rs</code> √© poss√≠vel acessar todos os atributos, inclusive os privados, com <code>use super::*</code>.</p>
<h3 id="tests-e-a-funcao-de-teste"><code>#[tests]</code> e a fun√ß√£o de teste<a class="zola-anchor" href="#tests-e-a-funcao-de-teste" aria-label="Anchor link for: tests-e-a-funcao-de-teste">üîó</a></h3>
<p>Agora que entendemos os m√≥dulos, vamo ver nosso teste:</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    // Foque nas duas linhas abaixo
    #[test]
    fn returns_branch_name_on_success() {}
}
</code></pre>
<p><code>#[test]</code> essa defini√ß√£o de atributo indica que o pr√≥ximo m√©todo √© um m√©todo de teste, logo ser√°
execultado quando rodarmos <code>cargo test</code>. (se n√£o sabia, esse √© o comando para rodar os testes :D)</p>
<p><code>fn returns_branch_name_on_success() {}</code> esta linha define o nome da fun√ß√£o de teste, quando
executarmos o comando <code>cargo test</code> esse nome ir√° ser exibido no terminal, indicando se passou ou n√£o.</p>
<h3 id="finalizando-a-primeira-iteracao">Finalizando a primeira itera√ß√£o<a class="zola-anchor" href="#finalizando-a-primeira-iteracao" aria-label="Anchor link for: finalizando-a-primeira-iteracao">üîó</a></h3>
<p>Nosso objetivo aqui √© criar a fun√ß√£o de teste e somente isso. Por que somente? No TDD damos passos
pequenos, mas andamos somente para frente, confiante de que o que constru√≠mos funciona e est√° validado.
Qualquer mudan√ßa no projeto que fizer o teste quebrar, significa que alguma regra de neg√≥cio foi
drasticamente alterada, atraindo nossa aten√ß√£o para corrigir o c√≥digo ou atualizar o testes.
Os testes n√£o est√£o escritos em pedra, mas s√≥ devem ser mudados como ultima escolha.</p>
<p>Sendo assim, vamos executar nossos testes</p>
<pre><code data-lang="sh">cargo test
</code></pre>
<p>Todos passando, vamos ent√£o fazer nosso commit, para registrarmos nosso primeiro <code>PASS</code>.</p>
<pre><code data-lang="sh">git add .
git commit -m &quot;feat: wip - inicializado os testes&quot;
</code></pre>
<p>Agora tudo salvo, vamos continuar para a pr√≥xima itera√ß√£o.</p>
<h2 id="tdd-segunda-iteracao-inicializando-o-mock">TDD: Segunda itera√ß√£o - Inicializando o mock<a class="zola-anchor" href="#tdd-segunda-iteracao-inicializando-o-mock" aria-label="Anchor link for: tdd-segunda-iteracao-inicializando-o-mock">üîó</a></h2>
<p>Agora que entendemos a estrutura do teste, vamos agora implementar nossa primeira linha do teste.</p>
<h3 id="iniciando-mock">Iniciando Mock<a class="zola-anchor" href="#iniciando-mock" aria-label="Anchor link for: iniciando-mock">üîó</a></h3>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;); // primeira linha do teste
    }
}
</code></pre>
<p>Nesta linha, estamos criando uma vari√°vel <code>fake</code>, isso √© indicado pela palavra chave <code>let</code>.<br />
<code>let fake</code></p>
<p>Depois disso, estamos chamando algo, que chama o m√©todo new e passa alguns argumentos.<br />
Esse algo √© o nosso mock, que est√° nomeado como <code>FakeRunner</code>.</p>
<p>A chamada do m√©todo se d√° atrav√©s dos <code>::</code>. Essa syntax somente se faz necess√°ria para o primeiro
m√©todo, os posteriores n√£o precisa, mas falaremos mais disso posteriormente.</p>
<p>Depois s√£o passados 3 argumentos:<br />
<code>true</code>: O primeiro do tipo boolean, que significa 1 ou 0, ou, verdadeiro ou falso;<br />
<code>"feature/test-branch\n"</code>: O segundo √© uma string, que representa o nome da branch;<br />
<code>""</code>: O terceiro neste momento √© uma string vazia, pois o objetivo √© que o terceiro seja a mensagem de erro.</p>
<hr />
<details>
<summary>Uma conversa sobre TDD, e o porqu√™ de implementar um m√©todo que n√£o existe ainda.</summary>
<blockquote>
<p>Lembre-se que no TDD implementamos o teste daquilo que desejamos implementar de verdade.
Parece bizarro pensar nessa metodologia, a princ√≠pio, tipo, por que testar algo que n√£o existe?</p>
<p>Na verdade, a ideia n√£o √© testar algo que n√£o existe, √© testar algo que vai existir.<br />
Se pensar da segunda forma, estamos na verdade estamos descrevendo nossos passos.<br />
Quando estudei no√ß√µes de algoritmos na faculdade, eu tinha que escrever coment√°rios que iriam
indicar o que eu deveria implementar. Algo como, "escrever fun√ß√£o de soma", "validar se divisor de 3",
e por ai vai.<br />
Voc√™ consegue ver a semelhan√ßa? Ao inv√©s de escrever um coment√°rio, eu escrevo uma linha no teste unit√°rio.</p>
<p>Assim, estou dizendo para mim que o algoritmo que desejo implementar, eu quero fazer um mock
chamado <code>FakeRunner</code>, e que esse mock deve receber tr√™s argumentos.</p>
</blockquote>
</details>
<hr />
<h3 id="criando-a-inicializacao-do-mock-fakerunner">Criando a inicializa√ß√£o do mock FakeRunner<a class="zola-anchor" href="#criando-a-inicializacao-do-mock-fakerunner" aria-label="Anchor link for: criando-a-inicializacao-do-mock-fakerunner">üîó</a></h3>
<p>O teste n√£o executar√° se tentar agora. Isso por que <code>FakeRunner</code> nem se quer existe.</p>
<p>Vamos ent√£o criar o <code>FakeRunner</code> que ser√° nosso mock</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    ////////////////////////
    // C√ìDIGO NOVO:
    struct FakeRunner {
    }
    ////////////////////////

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;); // primeira linha do teste
    }
}
</code></pre>
<p>Neste trecho do c√≥digo temos a palavra chave <code>struct</code>. Ela √© utilizada para definir uma estrutura.<br />
Structs podem ser utilizadas para definir diferentes coisas, orientando-se pelo conceito de chave e valor.</p>
<p>Em outras linguages, como <code>typescript</code>, <code>struct</code> pode ser comparado com <code>types</code>.
Ou em <code>java</code> ser comparado a um <code>record</code>.</p>
<p>Assim, o c√≥digo acima define uma estrutura (<code>struct</code>) chamada <code>FakeRunner</code>.</p>
<h3 id="implementando-metodo-new-do-mock-fakerunner">Implementando m√©todo NEW do mock FakeRunner<a class="zola-anchor" href="#implementando-metodo-new-do-mock-fakerunner" aria-label="Anchor link for: implementando-metodo-new-do-mock-fakerunner">üîó</a></h3>
<p>Agora que temos a estrutura do FakeRunner, precisamos implementar o diaxo do m√©todo <code>new</code>.</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
    }

    ///////////////////////////////////////////////////////////////////
    // C√≥digo novo
    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }
    ///////////////////////////////////////////////////////////////////

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;); // primeira linha do teste
    }
}
</code></pre>
<p>Eita que temos mais syntax para explicar agora. :|</p>
<p>Aqui temos outra palavra chave <code>impl</code>.
Esta palavra chave tem um significado sem√¢ntico para <strong>implementa√ß√£o</strong>.<br />
Logo podemos ler esta linha de c√≥digo como: <code>impl</code>ementa√ß√£o para <code>FakeRunner</code>.</p>
<p><code>impl</code> tem um papel de adicionar funcionalidade, ent√£o imagine que voc√™ est√°
adicionando uma funcionalidade a struct <code>FakeRunner</code>.<br />
Ent√£o, neste caso estamos adicionado a fun√ß√£o <code>new</code> a struct FakeRunner.</p>
<p>Como a struct √© s√≥ uma defini√ß√£o, ela n√£o possue fun√ß√µes, utilizamos impl para inserir
fun√ß√µes a estrutura definida.</p>
<p>Para definir uma fun√ß√£o utilizamos a palavra chave <code>fn</code> seguira pelo nome e os argumentos desejados,
e por fim o tipo do retorno.</p>
<p>No nosso exemplo temos <code>fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {</code>.</p>
<p><code>fn</code> define que estamos definindo uma fun√ß√£o.<br />
<code>new</code> √© p nome da func√£o que estamos implementando<br />
<code>(success: bool, stdout: &amp;str, stderr: &amp;str)</code> s√£o os argumentos necess√°rios para a fun√ß√£o.
Aqui temos 3 argumentos, <code>success</code> que √© do tipo bool (sim ou n√£o, true or false, verdadeiro ou falso); <code>stdout: &amp;str</code> e <code>stderr: &amp;str</code> s√£o √© um atributo de texto (string) que n√£o tomam posse do valor enviado (conceito de <a rel="external" href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">borrowing</a>);</p>
<p>Tamb√©m temos o retorno <code>-&gt; Self</code>, isso significa que o tipo de retorno √© a pr√≥pria struct.<br />
Qual a vantagem disso? Podemos fazer chamadas concatenadas como por exemplo se tivessimos uma calculadora, poderiamos executar: <code>Calculadora::new(10).mais(5).menos(2).restultado()</code>. Se resultado imprimir a resposta, ter√≠amos o resultado <strong>13</strong>, pois iniciamos a calculadora com o valor de <strong>10</strong>, depois somamos <strong>5</strong>, e depois subtra√≠mos <strong>2</strong>, resultando em <strong>13</strong>.</p>
<p>O mesmo <code>Self</code> √© utilizado dentro do m√©todo <code>new()</code>. Isso significa que o retorno do m√©todo altera algo interno da estrutura (struct) FakeRunner.<br />
Nesse exemplo que retornamos a pr√≥pria struct com o valor de result alterado.
Calma, √© sabido que n√£o temos ainda um <code>result</code> na struct, nem sabemos o que √© <code>RunResult</code>, mas lembre-se, √© TDD ;)</p>
<pre><code data-lang="rs">Self {
    result: RunResult {
        success,
        stdout: stdout.as_bytes().to_vec(),
        stderr: stderr.as_bytes().to_vec(),
    },
}
</code></pre>
<p>Queremos retornar um valor estruturado, onde temos o campo result, e este campo contem outra
estrutura que cont√©m valores, success, stdout, stderr. Logo,</p>
<p>O valor de result ser√° uma <code>struct RunResult</code>, que possue em seus campos utilizamos os argumentos enviados na chamada da func√£o.<br />
<code>stdout</code> e <code>stderr</code> recebem os valores no formato de um lista de bytes, por terem sidos definidos como <code>str</code>, logo <code>.as_bytes().to_vec()</code> converte primeiro o valor para bytes e depois transforma isso em uma lista de bytes.</p>
<p>Como ainda n√£o implementamos <code>RunResult</code> fica estranho ver toda essa convers√£o acontecendo aqui.
Mas, lembre-se, se n√£o existe ainda, √© porque estamos s√≥ definindo como vai ser.</p>
<h3 id="atualizando-struct-fakerunner">Atualizando struct FakeRunner<a class="zola-anchor" href="#atualizando-struct-fakerunner" aria-label="Anchor link for: atualizando-struct-fakerunner">üîó</a></h3>
<p>Dado que a implementa√ß√£o do m√©todo new est√° retornando uma estrutura que n√£o existe, precisamos implementa-la.
Assim, o nosso c√≥digo ficar√° da seguinte forma.</p>
<pre><code data-lang="rs">#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
      ////////////////////////////////
      // C√≥digo novo
      result: RunResult;
      ////////////////////////////////
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;); // primeira linha do teste
    }
}
</code></pre>
<p>Beleza, atualizamos nossa struct com o campo result que possui um tipo <code>RunResult</code>, mas agora
precisamos tamb√©m criar a struct <code>RunResult</code>, pois n√£o podemos finalizar nossa itera√ß√£o com erro.</p>
<p>A seguir, vamos finalmente implementar nossa estrutura RunResult.
Como ela tamb√©m far√° parte da nossa implementa√ß√£o final, pois iremos usar essa estrutura como retorno.
Devemos definir fora do modulo de testes.</p>
<h3 id="implementando-a-estrutura-runresult">Implementando a estrutura RunResult<a class="zola-anchor" href="#implementando-a-estrutura-runresult" aria-label="Anchor link for: implementando-a-estrutura-runresult">üîó</a></h3>
<p>RunResult como indiretamente vimos nos testes implementados acima, a estrutura ser√° a seguinte:</p>
<pre><code data-lang="rs">////////////////////////////////
// C√≥digo novo
#[derive(Clone, Debug)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}
////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
      result: RunResult;
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;); // primeira linha do teste
    }
}
</code></pre>
<p>Explicando o c√≥digo:</p>
<pre><code data-lang="rs">#[derive(Clone, Debug)]
pub struct RunResult {}
</code></pre>
<p>Aqui temos nossa defini√ß√£o de atributo usando a macro <code>derive</code>. Essa macro injeta m√©todos na <code>struct RunResult</code>.<br />
Logo, temos dois m√©todos adicionados na <code>struct</code>, <code>clone()</code> e funcionalidades de debug (<code>fmt::Debug</code>).</p>
<p><code>clone()</code> √© como o nome diz, clona, ele faz uma c√≥pia da sua estrutura para outra vari√°vel.<br />
Para que precisamos disso? O que faz de rust ser maravilhoso √© seu gerencimaneto de mem√≥ria.<br />
Com isso temos dois conceitos muito fortes no rust chamados <code>ownership</code> (posse) e <code>borrowing</code> (emprestar).<br />
Nesse caso, clone est√° relacionado a quest√£o da posse.</p>
<hr />
<details>
<summary>Explica√ß√£o de ownership por analogias</summary>
<blockquote>
<p>Por exemplo, se voc√™ deseja passar um valor de uma vari√°vel para outra e simplesmente fizer a atribui√ß√£o...</p>
<pre><code data-lang="rs">let a = &quot;Oi&quot;
let b = a
</code></pre>
<p>... voc√™ est√° n√£o s√≥ atribuindo outra vari√°vel, voc√™ est√° passando sua posse para outra vari√°vel. O que significa que <code>a</code> √© uma vari√°vel "abandonada" e se voc√™ tentar acessar o valor de <code>a</code> n√£o ser√° poss√≠vel.<br />
Isso se d√° por uma quest√£o de endere√ßo de mem√≥ria, passar a posse de a para b nada mais √© entregar para B o endere√ßo de mem√≥ria.<br />
Imagine que voc√™ pediu um delivery de uma pizza no restaurante. O restaurante faz sua pizza e manda pelo entregador, o entregador chega na sua casa e lhe entrega a pizza. Neste exemplo, o restaurante <code>possui</code> a pizza, <code>entrega</code> a pizza ao motoboy que far√° a entrega, e por fim o motoboy <code>entrega</code> a pizza a voc√™. Toda vez que h√° uma a√ß√£o de <code>entrega</code>, h√° uma tranfer√™ncia de posse daquele produto. Ent√£o:</p>
<pre><code data-lang="rs">let restaurante = &quot;pizza&quot;
let motoboy = restaurante
let fominha = motoboy
</code></pre>
<p>Quando utilizamos o m√©todo clone e copiamos o valor, o endere√ßo de mem√≥ria inicial √© preservado, pois aquele valor √© copiado para um novo endere√ßo de mem√≥ria e atribu√≠do a uma vari√°vel.<br />
Logo, podemos fazer uma analogia aleat√≥ria com um show de humor. A humorista faz a piada, na qual tem a risada, a risada √© compartilhada pelas pessoas, mas cada um possui sua pr√≥pria risada, e pode ter aquela pessoa que somente riu porque a pessoa do lado riu. Logo:</p>
<pre><code data-lang="rs">let humorista = &quot;risada&quot;
let pessoa1 = humorista.clone() // riu da piada
let pessoa2 = humorista.clone() // riu da piada
let pessoa3 = pessoa2.clone() // riu da pessoa2
</code></pre>
</blockquote>
</details>
<hr />
<p>Ao fazer <code>#[devive(debug)]</code> implementamos a possibilidade de imprimir/formatar o valor da struct.<br />
Logo, √© poss√≠vel executar os comandos abaixos:</p>
<pre><code data-lang="rs">let r = RunResult { success: true, stdout: b&quot;ok&quot;.to_vec(), stderr: vec![] };

println!(&quot;{:?}&quot;, r);
println!(&quot;{:#?}&quot;, r);
let _ = dbg!(r);
</code></pre>
<p>Agora voltamos a observar a estrutura completa</p>
<pre><code data-lang="rs">#[derive(Clone, Debug)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}
</code></pre>
<p>Ao definirmos a estrutura (struct) temos a palavra chave <code>pub</code>. Ela significa public (p√∫blico)
isso significa que nossa estrutura pode ser acessada fora do m√≥dulo que ela definiu.<br />
Em <strong>RUST</strong> por padr√£o tudo dentro do m√≥dulo √© privado, logo, pub se torna necess√°rio para dar acesso externo.</p>
<hr />
<details>
<summary>Explicando com exemplo o conceito de pub</summary>
<blockquote>
<p>Isso vale tamb√©m para os campos da <code>struct</code>, os campos precisam ser definidos com <code>pub</code> caso queira
dar acesso fora. Por exemplo:</p>
<pre><code data-lang="rs">pub struct Pizza {
    pub sabor: String,
    tempero: String,
}

let piza = Pizza {
  sabor = &quot;Sushi&quot;,
  tempero = &quot;brocolis&quot;
}

println!(piza.sabor) // funciona
println!(piza.tempero) // n√£o funciona
</code></pre>
</blockquote>
</details>
<hr />
<p>Os demais campos...</p>
<pre><code data-lang="rs">pub success: bool,
pub stdout: Vec&lt;u8&gt;,
pub stderr: Vec&lt;u8&gt;,
</code></pre>
<p>... s√£o defini√ß√µes das vari√°veis</p>
<ul>
<li><code>success</code> √© do tipo <code>bool</code>, aceitando valores bin√°rios como <code>true</code> ou <code>false</code></li>
<li><code>stdout</code> e <code>stderr</code> s√£o do tipo <code>Vec&lt;u8&gt;</code>, que significa aceitarem um vertor de <code>bytes</code> do tipo <code>unsigned 8-bit</code>
<ul>
<li>Esse formato √© util por aceitar dados bin√°rios arbitr√°rios (arquivos, sa√≠da de processos, rede), n√£o exibindo que seja um UTF-8 v√°lido.</li>
</ul>
</li>
</ul>
<h3 id="finalizando-a-iteracao">Finalizando a itera√ß√£o<a class="zola-anchor" href="#finalizando-a-iteracao" aria-label="Anchor link for: finalizando-a-iteracao">üîó</a></h3>
<p>Nesta itera√ß√£o vimos muitos conceitos e syntax novas, falamos de ownership, borrowing, pub, impl.<br />
Se desejar ter mais detalhes sobre, a documenta√ß√£o do rust √© bem completa :)</p>
<p>Agora vamos finalizar nossa itera√ß√£o.<br />
Execute os testes e vamos ver se eles passam:</p>
<pre><code data-lang="sh">cargo test
</code></pre>
<p>Com isso implementado, vamos ent√£o fazer nosso primeiro commit:</p>
<pre><code data-lang="sh">git add .;
git commit -m &quot;feat: wip - inicializando mock e adicionando estrutura da resposta&quot;
</code></pre>
<hr />
<blockquote>
<hr />
<p><strong>Daqui pra baixo temos a vers√£o antiga do texto</strong></p>
<p>Estou atualizando a did√°tica para ser mais pr√≥xima a como eu faria no "mundo real".</p>
</blockquote>
<hr />
<pre><code data-lang="markdown">## TDD: Segunda itera√ß√£o - GitRunner

Agora que temos uma estrutura de resposta, precisamos pensar numa estrutura para executar o c√≥digo.

Ent√£o, o que queremos fazer?  
Queremos ser capaz de executar um comando git passando uma lista de argumentos para ele.

Pensando agora na ideia do mock, n√≥s temos a `struct FakeRunner`, que representa nosso mock para
executar um comando `git`.  
Se desejamos criar uma fun√ß√£o na qual recebe argumentos para executar um comando git, para testar
nosso mock precisa fazer o mesmo.

Existe uma conceito nas linguagens orientada a objetos chamados de `interface`. Uma interface cria
um modelo de assinaturas de fun√ß√µes na qual toda classe que indica que a implementa,
precisar√° implementar os m√©todos listados por ela, com a mesma assinatura, e o mesmo retorno.  
Na orienta√ß√£o a objetos isso nos traz a vantagem de podemos usar a interface como o tipo o tipo para
uma vari√°vel, tendo assim a certeza que aquele objetos possuem as fun√ß√µes definidas pela interface.

Em Rust tamb√©m temos algo _similar_ (similar, mas n√£o igual) chamado de `trait`. Os traits podem definir
m√©todos na qual precisam ser implementados por aqueles que dizem que implementa. Logo, teremos as
mesmas fun√ß√µes, com os mermos argumentos e tipos de retornos, para todas as estruturas que o implementam.

### O Teste

Sabendo da exist√™ncia do `trait`, podemos usar este conceito para garantir que nosso mock tenha a
mesma chamada de m√©todo que a nossa implementa√ß√£o real. Tendo isso em mente, vamos ent√£o dizer em
nosso teste que teremos um `trait` chamado `GitRunner`

```rs
// ...c√≥digos da Primeira itera√ß√£o

#[cfg(test)]
mod tests {
  // ...c√≥digos da Primeira itera√ß√£o

    impl GitRunner for FakeRunner {
        fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
            Ok(self.result.clone())
        }
    }
}
```

Logo, com essa impelementa√ß√£o, n√≥s definimos que nosso modk

### Vamos entender as mudan√ßas:

- `impl GitRunner for FakeRunner {`: **impl**ementa√ß√£o de **GitRunner** **para** a estrutura **FakeRunner**. Essa linha indica que estamos implementando uma defini√ß√£o (trait) para estrutura `FakeRunner`. Em orienta√ß√£o a objeto seria como um `extends` ou `implements` e `GitRunner` seria considerada como uma `interface`. A forma como `impl` funciona √© interessante, √© como se fossemos adicionando novas funcionalidades a estrutura FakeRunner cada vez que utilizamos. A primeira vez, adicionamos new, da segunda vez, utilizamos uma defini√ß√£o (trait) para dizer que fun√ß√£o deveriamos implementar.

```rs
fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
    Ok(self.result.clone())
}
```

- O c√≥digo acima representa a fun√ß√£o definida no trait `GitRunner`. A assinatura do m√©todo, o tipo de retorno, tudo √© definido dentro de `GitRunner`. Mas, atrav√©s de `impl GitRunner for ...` √© quando a fun√ß√£o realmente √© implementada, deixando de ser somente uma assinatura.
- Nesse caso, n√≥s simplesmente retornamos uma c√≥pia do objeto result, que √© definido na fun√ß√£o `new`.

Agora vamos implementar `GitRunner` trait que √© utilizado como defini√ß√£o para `FakeRunner`

### Implementando pub trait GitRunner

```rs
pub trait GitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;
}
```

Vamos entender o c√≥digo acima:

- `pub trait GitRunner {`:
  - Assim como para struct, `pub` √© utilizado para definir esta trait como publica, com acesso externo.
- `fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;`:
  - √© a defini√ß√£o da fun√ß√£o `run`.
  - `&amp;mut self`
    - significa que estamos passando uma refer√™ncia que pode ser alterada de &quot;si mesmo&quot;,
  - `args: &amp;[&amp;str]`
    - significa que podemos receber um array sem limites de valores de texto (string)
  - `std::io::Result&lt;RunResult&gt;;`
    - √© outra forma de escrever `Result&lt;RunResult, std::io::Error&gt;`.
    - Isto √© usado como retorno de fun√ß√µes IO (input/output, entrada/sa√≠da), como √© no nosso caso, onde iremos executar um commando git&#39;.
    - O retorno √© um `Ok(RunResult)` caso de sucesso, retornando um resultado na estrutura de `RunResult`; Ou um valor de erro `Err(std::io::Error)` do tipo I/O.
    - Esse formato √© comumento usado para implementar `?` para propaga√ß√£o de error, bem como fun√ß√µes que executan I/O ou chamam outras API com retorno I/O.

Assim como em Orienta√ß√£o a Objeto, na qual temos uma `interface` que √© uma abstra√ß√£o de uma implementa√ß√£o real, e ent√£o implementamos uma `classe` que implementa esta `interface` de modo a termos uma classe concreta, em rust faremos algo semelhante.

### Finalizando a itera√ß√£o

Vamos ent√£o executar nosso teste:

```sh
cargo test
```

Tudo estando OKAY, podemos fazer nosso segundo commit:

```sh
git add .;
git commit -m &quot;feat: wip implementando trait GitRunner&quot;
```

### C√≥digo resultante deta itera√ß√£o

```rs
#[derive(Clone, Debug)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}

pub trait GitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;
}

#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
        result: RunResult,
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    impl GitRunner for FakeRunner {
        fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
            Ok(self.result.clone())
        }
    }
```

## TDD: Terceira itera√ß√£o - Git, the real implementation

Nesta itera√ß√£o faremos o teste que desejamos.

```rs
#[cfg(test)]
mod tests {
    /**
     * C√≥digo √° implementado
        struct FakeRunner {}
        impl FakeRunner {}
        impl GitRunner for FakeRunner {}
     */

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;);
        let mut git = Git::with_runner(Box::new(fake));
        let branch = git
            .get_current_branch_name()
            .expect(&quot;expected branch name on success&quot;);
        assert_eq!(branch, &quot;feature/test-branch&quot;);
    }
}
```

### Explicando o c√≥digo:

- `#[test]`:
  - Esse atributo indica que a fun√ß√£o seguinte √© um teste
- `fn returns_branch_name_on_success() {`:
  - Assinatura da fun√ß√£o, o nome da fun√ß√£o ser√° o nome exibido no terminal.
- `let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;);`:
  - nesta linha inicializamos o nosso mock runner.
  - Nele passamos o valor de sucesso e o nome da branh na qual querermos retornar, o terceiro par√¢metro √© de erro, n√£o necess√°rio neste teste.
- `let mut git = Git::with_runner(Box::new(fake));`:
  - Nesta linha implementamos o nossa implementa√ß√£o concreta do trait GitRunner. Iremos implementar a seguir, logo, o teste falhar√° por isso.

```rs
let branch = git
    .get_current_branch_name()
    .expect(&quot;expected branch name on success&quot;);
```

- O c√≥digo acima executa o m√©todo de git.
- `assert_eq!(branch, &quot;feature/test-branch&quot;);`:
  - aqui temos a nossa valida√ß√£o no teste. Esta linha que indica se o teste foi sucesso.

Agora que entendemos o teste implementado, vamos escrever nosso c√≥digo para passar

### Implementando RealGitRunner e impl Git

Neste c√≥digo acima temos a chamada do m√©todo, que ainda iremos implementar.

Iremos definir uma estrutura (`struct`) que ser√° nossa implementa√ß√£o concreta da nossa interface (`trait`).

```rs
pub struct RealGitRunner;
```

Abaixo temos a &quot;implementa√ß√£o concreta&quot;

```rs
impl GitRunner for RealGitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
        let output = Command::new(&quot;git&quot;).args(args).output()?;
        Ok(RunResult {
            success: output.status.success(),
            stdout: output.stdout,
            stderr: output.stderr,
        })
    }
}
```

Explicando o c√≥digo

- `impl GitRunner for RealGitRunner {`:
  - **implementar** o trait **GitRunner** **para** a estrutura **RealGitRunner**.
    - Parece l√≥gico n√©? Estamos implementando um `trait` em uma `struct`.
- `fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {`:
  - veja que cont√©m a mesma assinatura que o m√©todo do trait, isso significa que esta √© a implementa√ß√£o real da fun√ß√£o.
- `let output = Command::new(&quot;git&quot;).args(args).output()?;`:
  - Esta linha executa o comando do **git** passando a lista de argumentos.

```rs
Ok(RunResult {
    success: output.status.success(),
    stdout: output.stdout,
    stderr: output.stderr,
})
```

- As linhas acimas s√£o o retorno de sucesso da chamada da fun√ß√£o.
- Para nosso exemplo, n√£o precisaremos de um retorno de falha `Err()`, pois `output()?` j√° faz esse papel.

Agora vamos escrever a nossa implementa√ß√£o final:

```rs
pub struct Git {
    runner: Box&lt;dyn GitRunner&gt;,
}

impl Git {
    /// Create a client that uses the real `git` binary.
    pub fn real() -&gt; Self {
        Self {
            runner: Box::new(RealGitRunner),
        }
    }

    /// Create a client with a custom runner (useful for tests).
    pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {
        Self { runner }
    }

    /// Get the current branch name. Returns `Ok(branch)` on success or `Err(GitError)` on failure.
    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, GitError&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .map_err(GitError::Io)?;

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            let stderr = String::from_utf8_lossy(&amp;result.stderr).to_string();
            Err(GitError::GitFailed(stderr))
        }
    }
}
```

Vamos conversar sobre o c√≥digo:

```rs
pub struct Git {
    runner: Box&lt;dyn GitRunner&gt;,
}
```

- O c√≥digo acima define a estrutura do Git.
- `runner: Box&lt;dyn GitRunner&gt;,`:
  - Aloca√ß√£o de ponteiro-heap para algum tipo concreto de uma implementa√ß√£o do GitRunner, mas que em tempo de compila√ß√£o est√° vazio, pois sua aloca√ß√£o se d√° em tempo de execu√ß√£o. **Box&lt;&gt;** √© um trait que aloca um espa√ßo na mem√≥ria heap e armazena um ponteiro pr√≥prio para o conte√∫do. **dyn GitRunner**, √© um trait para objeto que habilita uso din√¢mico atrav√©s de uma [vtable](https://users.rust-lang.org/t/v-tables-differences-between-rust-and-c/92445/2) em tempo de execu√ß√£o.

Entendido como funciona a estutura, agora vamos a sua implementa√ß√£o:

```rs
impl Git {
    /// Create a client that uses the real `git` binary.
    pub fn real() -&gt; Self {
        Self {
            runner: Box::new(RealGitRunner),
        }
    }

    /// Create a client with a custom runner (useful for tests).
    pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {
        Self { runner }
    }

    /// Get the current branch name. Returns `Ok(branch)` on success or `Err(GitError)` on failure.
    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, GitError&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .map_err(GitError::Io)?;

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            let stderr = String::from_utf8_lossy(&amp;result.stderr).to_string();
            Err(GitError::GitFailed(stderr))
        }
    }
}
```

- `impl Git {`:
  - Inicializa√ß√£o da implementa√ß√£o da struct Git
- `pub fn real() -&gt; Self {`:
  - Esse m√©todo retorna uma implementa√ß√£o &quot;verdadeira&quot; para o uso real. O nome da func√£o ser `real()` √© uma conven√ß√£o. Isso indica que este m√©todo n√£o retorna um objeto mockado ou alguma vers√£o difereciada.

```rs
Self {
    runner: Box::new(RealGitRunner),
}
```

Essa parte do m√©todo `real()` executa um acesso a vari√°vel definida na `struct`. Este termo `Self` indica que estou dentro de um contexto interno.  
Sendo assim, o m√©todo altera o o valor de `runner` com um novo `Box` usando `RealGitRunner` como execult√°vel

- `pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {`:
  - este √© o maravilhoso m√©todo usado no teste. Ele aceita um par√¢metro do tipo `Box&lt;dyn GitRunner&gt;` e define ele no runner. Em outras linguagens de programa√ß√£o isso poderia ser chamado de um m√©todo `set`, mas por legibilidade `with_algumacoisa()` tem uma melhor legibilidade, sobretudo em chamadas de m√©todos concatenados.
- `Self { runner }`:
  - assim, o m√©todo somente tem uma defini√ß√£o direta do runner. Como o nome do par√¢metro da fun√ß√£o √© igual ao valor na struct, n√£o se faz necess√°rio escrever `runner: runner`.

Agora vamos falar do nosso m√©todo para consultar a branch:

```rs
pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, String&gt; {
  let result = self
      .runner
      .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
      .output()?

  if result.success {
      Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
  } else {
      Err(&quot;We have a problem&quot;)
  }
}
```

Vamos ent√£o explicar o c√≥digo:

- `pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, String&gt; {`:
  - Aqui temos a assinatura do m√©todo onde o par√¢metro da fun√ß√£o √© um `&amp;mut self`.
  - **&amp;mut self** aqui existe por conta da implementa√ß√£o din√¢mica do runner. Como a defini√ß√£o do runner n√£o √© feita em tempo de compila√ß√£o, a consequ√™ncia disso √© que precisamos dizer ao nosso m√©todo que `self` pode ser alterado a qualquer momento.
  - **Result&lt;String, GitError&gt;** significa que iremos retornar um `Ok()` (para sucesso) ou um `Err()` (para falha), onde o retorno de Ok √© uma string e o de Err √© um tipo String (Isso ir√° mudar na pr√≥xima itera√ß√£o para um erro mais customizado).

```rs
let result = self
    .runner
    .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
    .output()?
```

O c√≥digo acima execulta o comando do git atrav√©s do runner definido. Isso significa que para usar o m√©todo precisamos sempre fazer uma chamada em sequ√™ncia: `git.real().function_desired()`. Assim garantiremos que sempre teremos um runner definido em tempo de execu√ß√£o.

```rs
if result.success {
    Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
} else {
    Err(&quot;We have a problem&quot;)
}
```

Nesse trecho de c√≥digo, temos aqui uma valida√ß√£o do resultado do comando. Caso de sucesso, retornamos uma string. Caso falso, tamb√©m uma string, mas com mensagem de erro.  
`Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())`:

- `&amp;result.stdout`:
  - Cont√©m o resultado do comando em um formato de `bytecode`, um `Vec&lt;u8&gt;`.
  - O `&amp;` indica que estamos passando uma refer√™ncia ao valor, chamamos isso de [`borrowing`](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html).
    - **Borrowing** √© um conceito muito necess√°rio em Rust, vale a pena dedicar um tempo lendo sobre.
- `String::from_utf8_lossy(&amp;result.stdout)`:
  - Converte os bytes em um texto UTF-8. Usamos este m√©todo para converter bytes para texto UTF-8 com toler√¢ncia a falha, caso d√© erro, caracteres como `ÔøΩ` s√£o inseridos como `texto`
- `.trim()`:
  - remove espa√ßos em branco no in√≠cio e fim.
- `.to_string()`:
  - Converte o resultado em um String alocado (owned). Isso garante que quem chama o m√©todo ir√° deter posse do resultado ([ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)).
    - **Ownership** √© outro conceito de extrema import√¢ncia em rust.

&gt; Em um resumo nada convencional de explicar, ownership e borrowing s√£o os meios do rust de fazer com que a pessoa desenvolvedora seja respons√°vel pelo garbage collector :D

### Finalizando a itera√ß√£o

Agora com a implementa√ß√£o conclu√≠da, vamos verificar se os testes est√£o passando:

```sh
cargo test
```

Com tudo passando corretamente, vamos ent√£o efetuar mais um commit :)

```sh
git add .;
git commit -m &quot;feat: wip - criada implementa√ß√£o concreta do execut√°vel para o Git&quot;
```

Na pr√≥xima itera√ß√£o iremos concluir a primeira feature adicionando valida√ß√µes para os erros.

### C√≥digo resultante deta itera√ß√£o

```rs
#[derive(Clone, Debug)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}

pub trait GitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;
}

pub struct RealGitRunner;

impl GitRunner for RealGitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
        let output = Command::new(&quot;git&quot;).args(args).output()?;
        Ok(RunResult {
            success: output.status.success(),
            stdout: output.stdout,
            stderr: output.stderr,
        })
    }
}

pub struct Git {
    runner: Box&lt;dyn GitRunner&gt;,
}

impl Git {
    /// Create a client that uses the real `git` binary.
    pub fn real() -&gt; Self {
        Self {
            runner: Box::new(RealGitRunner),
        }
    }

    /// Create a client with a custom runner (useful for tests).
    pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {
        Self { runner }
    }

    /// Get the current branch name. Returns `Ok(branch)` on success or `Err(GitError)` on failure.
    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, GitError&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .map_err(GitError::Io)?;

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            let stderr = String::from_utf8_lossy(&amp;result.stderr).to_string();
            Err(GitError::GitFailed(stderr))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
        result: RunResult,
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    impl GitRunner for FakeRunner {
        fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
            Ok(self.result.clone())
        }
    }

    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, String&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .output()?

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            Err(&quot;We have a problem&quot;)
        }
    }
}
```

## TDD: Quarta itera√ß√£o - GitError, melhorando as mensagens de erros

At√© a terceira itera√ß√£o, j√° tinhamos o c√≥digo funcionando e testado.  
Mas, as mensagens de erros devem ser melhor trabalhadas.  
A pior coisa para um desenvolvedor √© ver um problema e n√£o ter a menor ideia do
motivo por traz daquilo.

Ent√£o, se iremos implementar uma rotina de teste mais bem elaborada, vamos ent√£o
escrever os testes para isso. A explica√ß√£o est√° condiga no pr√≥prio c√≥digo, atrav√©s de coment√°rios `//`

```rs
#[cfg(tests)]
mod test {
    /**
     * C√≥digo anterior j√° implementado, somente a primeira linha :D
    use super::*;
    struct FakeRunner {
    impl FakeRunner {
    impl GitRunner for FakeRunner {
    #[test]
    fn returns_branch_name_on_success() {
     */

    /**
     * Implementa√ß√£o do teste para quando falhar
     */
    // Defini√ß√£o da fun√ß√£o de teste com o nome que ser√° exibido ao rodar cargo tests
    #[test]
    fn returns_error_when_git_fails() {
        // Aqui temos a implementa√ß√£o do mock
        // Observe o detalhe que o segundo par√¢metro est√° vazio, isso indica que no
        //    caso de retorno OK ser√° um resultado vazio.
        // Logo o retorno desejado est√° no terceiro par√¢metro. Onde na implementa√ß√£o do mock
        //    corresponde ao retorno do erro.
        let fake = FakeRunner::new(false, &quot;&quot;, &quot;fatal: not a git repository\n&quot;);
        // Nesta linha √© inicializada a implementa√ß√£o do Git passando o mock runner acima.
        let mut git = Git::with_runner(Box::new(fake));
        // Aqui temos a utiliza√ß√£o da funcionalidade do match.
        // Em outras linguages o match se acemelha ao swithc-case. Na tradu√ß√£o literal match = corresponder.
        // Logo, na linha abaixo informamos que o retorno da fun√ß√£o conrresponde a algum dos resultados listados
        // Esta √© uma excelente forma de efetuar valida√ß√µes de diferentes casos de retorno.
        match git.get_current_branch_name() {
            // Na linha abaixo estamos correspondendo o retorno de get_current_branch_name
            //    ao tipo Err(GitError::GitFailed(msg)). Aqui vemos o teste da nossa nova implementa√ß√£o
            Err(GitError::GitFailed(msg)) =&gt; {
                assert!(msg.contains(&quot;not a git repository&quot;));
            }
            // Nas duas linhas abaixo retornamos o teste usando panic!
            // panic! √© uma macro que dispara um evento de falha do projeto.
            // Este erro interrompe a execu√ß√£o do programa, e exibe a mensagem definida.
            // Estes dois casos abaixos indicam que o nosso teste deve obrigatoriamente retornar
            //    um tipo Err(GitError::GitFailed(msg)), do contr√°rio algo de errado n√£o est√° certo.
            Err(e) =&gt; panic!(&quot;expected GitFailed, got {:?}&quot;, e),
            Ok(v) =&gt; panic!(&quot;expected error, got success {:?}&quot;, v),
            _ =&gt; panic!(&quot;expected error, got success {:?}&quot;, v),
        }
    }
}
```

---

&lt;details&gt;

  &lt;summary&gt;Sobre o match e sua semalhan√ßa com `switch-case` de outras linguagens&lt;/summary&gt;

O [`match`](https://doc.rust-lang.org/book/ch06-02-match.html) pode ser utilizado em diversos casos,
n√£o s√≥ no tratamento de retorno. Ele √© uma estrutura de controle, assim como if-else.  
 Em outras linguagens, seria o mesmo que um switch case, veja abaixo:

```php
// Javascript ou Typescript ou Java ou Php
switch (expression) {
  case value1:
    // Code to execute if expression === value1
    break;
  case value2:
    // Code to execute if expression === value2
    break;
  // ... more cases
  default:
    // Code to execute if no case matches
}
```

J√° python, a partir da vers√£o 3.10 temos algo semelhante ao match de rust:

```python
match choice:
    case &#39;A&#39;:
        print(&quot;You selected option A.&quot;)
    case &#39;B&#39;:
        print(&quot;You selected option B.&quot;)
    case &#39;C&#39;:
        print(&quot;You selected option C.&quot;)
    case _:  # Wildcard for default case
        print(&quot;Unknown selection.&quot;)
```

```rs
match number {
    1 =&gt; println!(&quot;The number is one.&quot;),
    2 | 3 =&gt; println!(&quot;The number is two or three.&quot;), // Matching multiple values
    4..=6 =&gt; println!(&quot;The number is between four and six (inclusive).&quot;), // Matching a range
    _ =&gt; println!(&quot;The number is something else.&quot;), // Catch-all pattern
}
```

&lt;/details&gt;

---

### C√≥digo resultante deta itera√ß√£o

```rs
/// Error type for git helpers.
#[derive(Debug)]
pub enum GitError {
    Io(std::io::Error),
    GitFailed(String),
}

impl fmt::Display for GitError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {
        match self {
            GitError::Io(e) =&gt; write!(f, &quot;IO error: {}&quot;, e),
            GitError::GitFailed(s) =&gt; write!(f, &quot;git command failed: {}&quot;, s),
        }
    }
}

impl Error for GitError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#39;static)&gt; {
        match self {
            GitError::Io(e) =&gt; Some(e),
            GitError::GitFailed(_) =&gt; None,
        }
    }
}

impl From&lt;std::io::Error&gt; for GitError {
    fn from(e: std::io::Error) -&gt; Self {
        GitError::Io(e)
    }
}

#[derive(Clone, Debug)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}

pub trait GitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;
}

pub struct RealGitRunner;

impl GitRunner for RealGitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
        let output = Command::new(&quot;git&quot;).args(args).output()?;
        Ok(RunResult {
            success: output.status.success(),
            stdout: output.stdout,
            stderr: output.stderr,
        })
    }
}

pub struct Git {
    runner: Box&lt;dyn GitRunner&gt;,
}

impl Git {
    /// Create a client that uses the real `git` binary.
    pub fn real() -&gt; Self {
        Self {
            runner: Box::new(RealGitRunner),
        }
    }

    /// Create a client with a custom runner (useful for tests).
    pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {
        Self { runner }
    }

    /// Get the current branch name. Returns `Ok(branch)` on success or `Err(GitError)` on failure.
    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, GitError&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .map_err(GitError::Io)?;

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            let stderr = String::from_utf8_lossy(&amp;result.stderr).to_string();
            Err(GitError::GitFailed(stderr))
        }
    }

    #[test]
    fn returns_error_when_git_fails() {
        let fake = FakeRunner::new(false, &quot;&quot;, &quot;fatal: not a git repository\n&quot;);
        let mut git = Git::with_runner(Box::new(fake));
        match git.get_current_branch_name() {
            Err(GitError::GitFailed(msg)) =&gt; {
                assert!(msg.contains(&quot;not a git repository&quot;));
            }
            Err(e) =&gt; panic!(&quot;expected GitFailed, got {:?}&quot;, e),
            Ok(v) =&gt; panic!(&quot;expected error, got success {:?}&quot;, v),
            _ =&gt; panic!(&quot;expected error, got success {:?}&quot;, v),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct FakeRunner {
        result: RunResult,
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    impl GitRunner for FakeRunner {
        fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
            Ok(self.result.clone())
        }
    }

    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, String&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .output()?

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            Err(&quot;We have a problem&quot;)
        }
    }
}
```

## Resultado final

```rs
/ ...existing code...
use std::process::Command;
use std::{error::Error, fmt};

/// Small, test-friendly representation of a command run result.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct RunResult {
    pub success: bool,
    pub stdout: Vec&lt;u8&gt;,
    pub stderr: Vec&lt;u8&gt;,
}

/// Trait to abstract running git commands so tests can inject a fake runner.
pub trait GitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt;;
}

/// Real runner that invokes the system `git` command.
pub struct RealGitRunner;

impl GitRunner for RealGitRunner {
    fn run(&amp;mut self, args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
        let output = Command::new(&quot;git&quot;).args(args).output()?;
        Ok(RunResult {
            success: output.status.success(),
            stdout: output.stdout,
            stderr: output.stderr,
        })
    }
}

/// Error type for git helpers.
#[derive(Debug)]
pub enum GitError {
    Io(std::io::Error),
    GitFailed(String),
}

impl fmt::Display for GitError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {
        match self {
            GitError::Io(e) =&gt; write!(f, &quot;IO error: {}&quot;, e),
            GitError::GitFailed(s) =&gt; write!(f, &quot;git command failed: {}&quot;, s),
        }
    }
}

impl Error for GitError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#39;static)&gt; {
        match self {
            GitError::Io(e) =&gt; Some(e),
            GitError::GitFailed(_) =&gt; None,
        }
    }
}

impl From&lt;std::io::Error&gt; for GitError {
    fn from(e: std::io::Error) -&gt; Self {
        GitError::Io(e)
    }
}

/// Lightweight Git client that holds a runner. Use in tests by injecting a FakeRunner.
pub struct Git {
    runner: Box&lt;dyn GitRunner&gt;,
}

impl Git {
    /// Create a client that uses the real `git` binary.
    pub fn real() -&gt; Self {
        Self {
            runner: Box::new(RealGitRunner),
        }
    }

    /// Create a client with a custom runner (useful for tests).
    pub fn with_runner(runner: Box&lt;dyn GitRunner&gt;) -&gt; Self {
        Self { runner }
    }

    /// Get the current branch name. Returns `Ok(branch)` on success or `Err(GitError)` on failure.
    pub fn get_current_branch_name(&amp;mut self) -&gt; Result&lt;String, GitError&gt; {
        let result = self
            .runner
            .run(&amp;[&quot;rev-parse&quot;, &quot;--abbrev-ref&quot;, &quot;HEAD&quot;])
            .map_err(GitError::Io)?;

        if result.success {
            Ok(String::from_utf8_lossy(&amp;result.stdout).trim().to_string())
        } else {
            let stderr = String::from_utf8_lossy(&amp;result.stderr).to_string();
            Err(GitError::GitFailed(stderr))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Fake runner that returns a predetermined RunResult.
    struct FakeRunner {
        result: RunResult,
    }

    impl FakeRunner {
        fn new(success: bool, stdout: &amp;str, stderr: &amp;str) -&gt; Self {
            Self {
                result: RunResult {
                    success,
                    stdout: stdout.as_bytes().to_vec(),
                    stderr: stderr.as_bytes().to_vec(),
                },
            }
        }
    }

    impl GitRunner for FakeRunner {
        fn run(&amp;mut self, _args: &amp;[&amp;str]) -&gt; std::io::Result&lt;RunResult&gt; {
            Ok(self.result.clone())
        }
    }

    #[test]
    fn returns_branch_name_on_success() {
        let fake = FakeRunner::new(true, &quot;feature/test-branch\n&quot;, &quot;&quot;);
        let mut git = Git::with_runner(Box::new(fake));
        let branch = git
            .get_current_branch_name()
            .expect(&quot;expected branch name on success&quot;);
        assert_eq!(branch, &quot;feature/test-branch&quot;);
    }

    #[test]
    fn trims_whitespace_from_branch_name() {
        let fake = FakeRunner::new(true, &quot;  feature/trim  \n&quot;, &quot;&quot;);
        let mut git = Git::with_runner(Box::new(fake));
        let branch = git.get_current_branch_name().unwrap();
        assert_eq!(branch, &quot;feature/trim&quot;);
    }

    #[test]
    fn returns_error_when_git_fails() {
        let fake = FakeRunner::new(false, &quot;&quot;, &quot;fatal: not a git repository\n&quot;);
        let mut git = Git::with_runner(Box::new(fake));
        match git.get_current_branch_name() {
            Err(GitError::GitFailed(msg)) =&gt; {
                assert!(msg.contains(&quot;not a git repository&quot;));
            }
            Err(e) =&gt; panic!(&quot;expected GitFailed, got {:?}&quot;, e),
            Ok(v) =&gt; panic!(&quot;expected error, got success {:?}&quot;, v),
        }
    }
}
```
</code></pre>
</div>
  </article>

  
  <aside>
    <h3>√çndice</h3>
    <ul>
      
      <li>
        <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#contexto">Contexto</a>
        
      </li>
      
      <li>
        <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#sobre-a-implementacao">Sobre a implementa√ß√£o</a>
        
      </li>
      
      <li>
        <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#tdd-primeira-iteracao-iniciando-nossa-funcao-de-teste">TDD: Primeira itera√ß√£o - Iniciando nossa fun√ß√£o de teste</a>
        
        <ul>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#cfg-test-e-mod-tests">#[cfg(test)] e mod tests</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#tests-e-a-funcao-de-teste">#[tests] e a fun√ß√£o de teste</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#finalizando-a-primeira-iteracao">Finalizando a primeira itera√ß√£o</a>
          </li>
          
        </ul>
        
      </li>
      
      <li>
        <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#tdd-segunda-iteracao-inicializando-o-mock">TDD: Segunda itera√ß√£o - Inicializando o mock</a>
        
        <ul>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#iniciando-mock">Iniciando Mock</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#criando-a-inicializacao-do-mock-fakerunner">Criando a inicializa√ß√£o do mock FakeRunner</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#implementando-metodo-new-do-mock-fakerunner">Implementando m√©todo NEW do mock FakeRunner</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#atualizando-struct-fakerunner">Atualizando struct FakeRunner</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#implementando-a-estrutura-runresult">Implementando a estrutura RunResult</a>
          </li>
          
          <li>
            <a href="https://oxechicao.github.io/manguetown/posts/criando-comando-para-ler-nome-da-branch-atual/#finalizando-a-iteracao">Finalizando a itera√ß√£o</a>
          </li>
          
        </ul>
        
      </li>
      
    </ul>
  </aside>
  
</div>
</main>
    </div>
    <footer>
      <section>
        <div class="footer-content">
          <div class="flex-left-middle">
            <span class="statusbar-1">Copyright &copy;</span>
            <span class="statusbar-2">2026</span>
            <span class="font-thin"> All Rights Reserved. </span>
          </div>
          <div class="flex-left-middle">
            <span class="statusbar--r--2">
              <img
                src="https://oxechicao.github.io/manguetown/crab-svgrepo-com.svg"
                width="18px"
              />
              <a
                class="light-link"
                href="https://oxechicao.github.io/"
                target="_blank"
                >@oxechicao</a
              >
            </span>
            <div class="statusbar--r--1">
              <img
                src="https://oxechicao.github.io/manguetown/open-source-fill-svgrepo-com.svg"
                width="18px"
              />
              <a
                class="dark-link"
                href="https://github.com/oxechicao/manguetown"
                target="_blank"
                >Github Project</a
              >
            </div>
          </div>
        </div>
      </section>
    </footer>
  </body>
</html>
